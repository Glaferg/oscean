<!DOCTYPE html><html lang='en'></head><meta charset='utf-8'><meta name='description' content='Fractran is insanely difficult to program in, but based on one of the most bizarrely elegant concepts of computation.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV — fractran</title></head><body><header><a href='home.html'><img src='../media/icon/logo.svg' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='arithmetic.html'>arithmetic/</a></li><li><a href='language.html'>language</a></li><li><a href='computation.html'>computation</a></li><li><a href='hardware.html'>hardware</a></li><li><a href='mirrors.html'>mirrors</a></li><li><a href='notebook.html'>notebook</a></li></ul><ul><li><a href='binary.html'>binary</a></li><li><a href='reverse_polish.html'>reverse polish</a></li><li><a href='fractran.html'>fractran/</a></li></ul><ul></ul></nav><main><h2>Fractran is insanely difficult to program in, but based on one of the most bizarrely elegant concepts of computation.</h2><p>A Fractran program is an ordered list of positive fractions together with an initial positive integer input. The program is run by updating the accumulator.</p><figure><img src='../media/refs/fractran.jpg' width='340'/>&nbsp;<figcaption>—The Book of Numbers, <a href='https://en.wikipedia.org/wiki/John_Horton_Conway' target='_blank'>John Conway</a></figcaption></figure><p>Any number that can't be divided by any other number, apart from itself and one, is prime. Since primes can't be divided, we can think of them as the DNA of other numbers. In Fractran, each prime is a register and their exponent is their value. </p><figure><h3>The Accumulator</h3>

<p>The <b>state of the accumulator</b> is held as a single number, whose prime factorization holds these registers(2, 3, 5, 7, 11, 13, 17, ..). If the state of the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value 2, r7 has the value 1, and all other registers are unassigned. </p>

<table border='1'>
	<tr><th>accumulator</th><th colspan='4'>registers</th></tr>
	<tr><th></th><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<h3>The Operators</h3>

<p>A fractran operation is a positive fraction, each fraction represents an instruction that tests one or more registers, represented by the prime factors of its denominator. The Fractran computer goes through each fraction in order, in terms of our current accumulator value.</p>

<img src='../media/refs/fractran.adder1.jpg' width='140px'/>

<pre>18(2<sup>1</sup> × 3<sup>2</sup>) <b>2/3</b> = 8(2<sup>3</sup>) <i>addition</i></pre>

<p>To run the <i>adder operation</i>(<code>2/3</code>), we will take the state of the accumulator. If multiplying it by this fraction will give us an integer, we will do so and start again at the beginning of the program. Otherwise, we will stop and consider the program complete. We will do this repeatedly until we can no longer produce an integer with this method. </p>

<table border='1'>
	<tr><th rowspan='2'>steps</th><th rowspan='2'>state</th><th colspan='2'>registers</th></tr>
	<tr><th>r2</th><th>r3</th></tr>
	<tr style='background:#eee'><td>1</td><th>18</th><td>1</td><td>2</td><td>18 × 2/3 = 12/1</td><td>INT, RESTART</td></tr>
	<tr><td>2</td><th>12</th><td>2</td><td>1</td><td>12 × 2/3 = 8/1</td><td>INT, RESTART</td></tr>
	<tr><td>3</td><th>8</th><td>3</td><td></td><td>8 × 2/3 = 16/3</td><td>NOT INT, END</td></tr>
</table>

<p>To add the values 1 and 2, we will store the values in registers 2 and 3, our starting state is therefore 18(2<sup>1</sup> × 3<sup>2</sup>).</p>

<p>For each step of the program, we will multiply our state with the program(18 × 2/3 = 12, 12 × 2/3 = 8, ..) until our our working value cannot be reduced to a whole number(16/3), we have exhausted the program. Alternatively, the program <code>3/2</code> will do the same operation but store the result in the register 3. </p>

<pre>576(2<sup>6</sup> × 3<sup>2</sup>) <b>1/6</b> = 16(2<sup>4</sup>) <i>subtraction</i></pre>

<p>Operations become more readable when broken down into their primes. We can think of every prime number as having a register which can take on non-negative integer values. Each fraction is an instruction that operates on some of the registers.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span class='numreg'>2</span><sup class='numval'>1</sup>)/(<span class='denreg'>3</span><sup class='denval'>1</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>5</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>6</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>7</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>2</sup> × <span class='denreg'>5</span><sup class='denval'>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(<span class='denreg'>r3</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r3</span> -= <span class='denval'>1</span>;
	<span class='numreg'>r2</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>6</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>6</span>;
	<span class='numreg'>r3</span> += <span class='numval'>1</span>;
	<span class='numreg'>r5</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>2</span> && <span class='denreg'>r5</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>2</span>; 
	<span class='denreg'>r5</span> -= <span class='denval'>1</span>; 
	<span class='numreg'>r3</span> += <span class='numval'>1</span>; 
	<span class='numreg'>r7</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
	</tr>
</table>

<style>
	.numreg { background:pink }
	.numval { background:#ffdee4 }
	.denreg { background:#72dec2 }
	.denval { background:#ffd18c }
</style>

<p>You can interpret a fraction as saying if the current value of each register is greater than or equal to the the value specified by the denominator, you subtract from the registers all of the values in the denominator, add all the values specified in the numerator, and then jump back to the first instruction. Otherwise, if any register is less than the value specified in the denominator, continue to the next fraction.</p>

<h3>The Programs</h3>

<img src='../media/refs/fractran.adder2.jpg' width='160px'/>

<h3>Interpreter</h3>

<p>A simple Fractran interpreter, written in <a href='ansi_c'>ANSI C</a>, showing the value in the registers as it steps through the program.</p>

<pre>
#include &lt;stdio.h&gt;

/* 
Copyright (c) 2020 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

typedef struct Fraction {
	unsigned int num, den;
} Fraction;

typedef struct Machine {
	int len;
	Fraction acc, program[256];
} Machine;

int
gcd(int a, int b)
{
	if(b == 0)
		return a;
	return gcd(b, a % b);
}

Fraction
Frac(unsigned int num, unsigned int den)
{
	Fraction f;
	unsigned int d = gcd(num, den);
	f.num = num / d;
	f.den = den / d;
	return f;
}

void
printstate(Machine *m)
{
	unsigned int fac = 2, num = m->acc.num;
	printf("[%d] ", num);
	while(num > 1) {
		if(num % fac == 0) {
			unsigned int pow = 1;
			printf("r%02u=", fac);
			num /= fac;
			while(!(num % fac)) {
				num /= fac;
				pow++;
			}
			printf("%02u", pow);
			if(num != 1)
				putchar(' ');
		} else
			fac++;
	}
	putchar('\n');
}

void
run(Machine *m)
{
	int i = 0;
	while(i < m->len && m->acc.num) {
		Fraction res, *f = &m->program[i++];
		res = Frac(m->acc.num * f->num, m->acc.den * f->den);
		printf("%u × %u/%u = %u/%u \n",
			m->acc.num,
			f->num,
			f->den,
			res.num,
			res.den);
		if(res.den == 1) {
			m->acc = res;
			printstate(m);
			i = 0;
		}
	}
}

void
push(Machine *m, char *w)
{
	Fraction f;
	if(!m->acc.den) {
		if(sscanf(w, "%u", &m->acc.num) > 0)
			m->acc.den = 1;
		return;
	}
	if(sscanf(w, "%u/%u", &f.num, &f.den) > 0)
		m->program[m->len++] = f;
}

Machine m;

int
main(void)
{
	int len = 0;
	char c, word[64];
	while((c = fgetc(stdin)) != EOF) {
		if(c == ' ' || c == '\n') {
			word[len] = '\0';
			len = 0;
			push(&m, word);
		} else
			word[len++] = c;
		if(c == '\n')
			break;
	}
	printstate(&m);
	run(&m);
	printstate(&m);
	return 0;
}
</pre>
<figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/html/fractran.htm' target='_blank'>edit</a> to <a href='../src/inc/html/fractran.htm'>fractran.htm</a>(219 lines)</figcaption>
</figure><ul><li><a href='https://git.sr.ht/~rabbits/fractran' target='_blank'>Fractran Interpreter(C89)</a></li><li><a href='https://esoteric.codes/blog/an-intro-to-fractran' target='_blank'>Intro to Fractran</a></li><li><a href='https://esolangs.org/wiki/Fractran' target='_blank'>Article on Esolang</a></li><li><a href='https://esolangs.org/wiki/Collatz_function' target='_blank'>Collatz function</a></li><li><a href='https://en.wikipedia.org/wiki/Register_machine' target='_blank'>Register Machine</a></li><li><a href='https://en.wikipedia.org/wiki/One-instruction_set_computer' target='_blank'>OISC</a></li></ul><p><i>incoming(1)</i>: <a href='firth.html'>firth</a> </p><p><i>Last update on <a href='tracker.html'>20Y10</a>, edited 4 times. +14/31fh</i><code style='float:right; font-size:80%'>------</code></p></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> © 2020 — <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>