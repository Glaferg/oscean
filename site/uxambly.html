<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'><meta name='description' content='Uxambly is a programming language for the Uxn stack-machine.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV &mdash; uxambly</title></head><body><header><a href='home.html'><img src='../media/icon/logo.svg' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='orca.html'>orca</a></li><li><a href='gyo.html'>gyo</a></li><li><a href='uxn.html'>uxn/</a></li><li><a href='noton.html'>noton</a></li><li><a href='paradise.html'>paradise</a></li></ul><ul><li><a href='uxambly.html'>uxambly/</a></li><li><a href='uxnemu.html'>uxnemu</a></li><li><a href='roms.html'>roms</a></li></ul><ul></ul></nav><main><h2>Uxambly is a programming language for the Uxn stack-machine.</h2><p>The <a href='uxn.html'>Uxn</a> cpu understands 8-bit machine code, and that code corresponds to operations and values used in programs. The programming language that turns source code into Uxn roms, is called <b>Uxambly</b>, it's a unique flavor of <a href='assembly.html'>assembly</a> designed for this special stack-machine.</p><img src='../media/generic/uxn.beet.png' width='150' style='float:left'/><p>Stack machine programming might look at bit odd, as it uses a <a href='reverse_polish.html'>postfix notation</a>, which means that operators are always found at the end of an operation. For instance, one would write <code>3 4 +</code> instead of <code>3 + 4</code>. The expression written <code>(5 + 10) * 3</code> in conventional notation would be written <code>3 10 5 + *</code> in reverse Polish notation.</p><hr style='border:0'/><figure><h2>Opcodes</h2>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 are used to select modes of that opcode, modes are explained below.</p>

<table border='1'>
	<tr><td colspan='3'>mode</td><td colspan='5'>opcode</td></tr>
	<tr><td><i>nil</i></td><td>return<code>[r]</code></td><td>short<code>[2]</code></td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<p>Opcodes using memory addresses can pop 2 bytes at once to form an absolute address, or a single one to create a relative address in the case of jump opcodes, or a the zero-page address in the case of peek/poke opcodes. For example, if <code>[0xAB 0xCD]</code> is present on the stack, it will be used by <code>JMP2</code> to point to the memory address <code>0xABCD</code>.</p>

<table border='1' width='700'>
	<tr><td></td><th colspan='3'>Stack</th><td></td>                                          <th colspan='3'>Memory</th></tr>
	<tr><th>0x00</th><td><code class='op'>BRK</code> Break</td><td></td><td></td>             <th>0x10</th><td><code class='op'>PEK</code> LoadByte</td><td>[a]</td><td>b</td></tr>
	<tr><th>0x01</th><td><code class='op'>LIT</code> Literal</td><td>++</td><td></td>         <th>0x11</th><td><code class='op'>POK</code> StoreByte</td><td>a [b]</td><td></td></tr>
	<tr><th>0x02</th><td><code class='op'>---</code> </td><td></td><td></td>                  <th>0x12</th><td><code class='op'>LDR</code> LoadShort</td><td>[a]</td><td>c</td></tr>
	<tr><th>0x03</th><td><code class='op'>POP</code> Pop</td><td>a</td><td></td>              <th>0x13</th><td><code class='op'>STR</code> StoreShort</td><td>a [b]</td><td></td></tr>
	<tr><th>0x04</th><td><code class='op'>DUP</code> Duplicate</td><td>a</td><td>a a</td>     <th>0x14</th><td><code class='op'>JMP</code> Jump</td><td>[a]</td><td></tr>
	<tr><th>0x05</th><td><code class='op'>SWP</code> Swap</td><td>a b</td><td>b a</td>        <th>0x15</th><td><code class='op'>JNZ</code> JumpCond</td><td>a [b]</td><td></td></tr>
	<tr><th>0x06</th><td><code class='op'>OVR</code> Over</td><td>a b</td><td>a b a</td>      <th>0x16</th><td><code class='op'>JSR</code> JumpStash</td><td>[a]</td><td>rs</td></tr>
	<tr><th>0x07</th><td><code class='op'>ROT</code> Rotate</td><td>a b c</td><td>b c a</td>  <th>0x17</th><td><code class='op'>STH</code> Stash</td><td>a</td><td>rs</td></tr>
	<tr><td></td><th colspan='3'>Logic</th><td></td>                                          <th colspan='3'>Arithmetic</th></tr>
	<tr><th>0x08</th><td><code class='op'>EQU</code> Equal</td><td>a b</td><td>c</td>         <th>0x18</th><td><code class='op'>ADD</code> Add</td><td>a b</td><td>c</td></tr>
	<tr><th>0x09</th><td><code class='op'>NEQ</code> NotEqual</td><td>a b</td><td>c</td>      <th>0x19</th><td><code class='op'>SUB</code> Subtract</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0a</th><td><code class='op'>GTH</code> GreaterThan</td><td>a b</td><td>c</td>   <th>0x1a</th><td><code class='op'>MUL</code> Multiply</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0b</th><td><code class='op'>LTH</code> LesserThan</td><td>a b</td><td>c</td>    <th>0x1b</th><td><code class='op'>DIV</code> Divide</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0c</th><td><code class='op'>GTS</code> GreaterSign</td><td>as bs</td><td>c</td> <th>0x1c</th><td><code class='op'>AND</code> And</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0d</th><td><code class='op'>LTS</code> LesserSign</td><td>as bs</td><td>c</td>  <th>0x1d</th><td><code class='op'>ORA</code> Or</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0e</th><td><code class='op'>---</code></td><td></td><td></td>                   <th>0x1e</th><td><code class='op'>EOR</code> ExclusiveOr</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0f</th><td><code class='op'>---</code></td><td></td><td></td>                   <th>0x1f</th><td><code class='op'>SFT</code> Shift</td><td>a b</td><td>c</td></tr>
</table>

<p><code>rs</code> for <i>return stack</i>.</p>

<img src='../media/generic/uxn.team.png' width='250' style='margin:0 auto 30px'/>

<h2>Addressing</h2>

<p>The memory and stacks contains 8-bits values, to differentiate operations from literal numbers, the <code class='op'>LIT</code> opcode will push the following byte from memory onto the stack, the 16-bits mode <code class='op'>LIT2</code> opcode will push the following short.</p>

<p><b>Immediate</b>, or literal, addressing allows to directly specify a byte or short constant. <b>Deferred</b> addressing is a form of immediate addressing where the address of a label is put on the stack. </p>

<table border='1'>
	<tr><th></th><th colspan="2">Byte</th><th>Short</th></tr>
	<tr><td><i>Immediate</i></td><td colspan="2"><code>#ab</code></td><td><code>#cdef</code></td></tr>
	<tr><td rowspan="2"><i>Deferred</i></td><th>Zero-page</th><th>Relative</th><th>Absolute</th></tr>
	<tr><td><code>.label</code></td><td><code>,label</code></td><td><code>;label</code></td></tr>
</table>

<h2>Programming</h2>

<p>Uxambly allows for basic control flow, here are some of them:</p>

<table border='1'>
	<tr><th>ForLoop</th><th>WhileLoop</th><th>Switch</th></tr>
	<tr>
		<td>
<pre>
#00 #0d
$loop
	( body ) 
	SWP #01 ADD SWP
	DUP2 LTH ;$loop JNZ
POP2
</pre>
		</td>
		<td>
<pre>
#00 #0d
$while
	( body )
	DUP2 EQU ;$end JNZ
	SWP #01 ADD SWP
;$while JMP $end
POP2
</pre>
		</td>
		<td>
<pre>
#02 
DUP #01 NEQ ;$b JNZ
	( a ) 
$b DUP #02 NEQ ;$c JNZ
	( b ) 
$c DUP #03 NEQ ;$default JNZ
	( c ) 
$default
POP
</pre>
		</td>
	</tr>

</table>

<p>Here is an example of the assembly language that prints <code>hello world</code> to stdout. Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune.</p>

<pre style='clear:both'>
%RTN { JMP2r }

( devices )

|0110 :Console { vector 2 pad 6 char 1 byte 1 short 2 string 2 }

( program )

|0200
	
	,text1 ,print-label JSR2
	,text2 ,print-label JSR2
	#ab =Console.byte
	#cdef =Console.short

BRK

@print-label ( text )
	
	$loop
		( send ) DUP2 PEK2 =Console.char
		( incr ) #0001 ADD2
		( loop ) DUP2 PEK2 #00 NEQ ;$loop JNZ
	POP2

RTN    

@text1 [ Welcome 20 to 20 UxnVM 0a00 ]
@text2 [ Hello 20 World 0a00 ] 
</pre>

<h2>Operator Modes</h2>

<p>Modes are indicated by appending extra characters at the end of the opcode, for example, the 16-bit mode of the <code class='op'>ADD</code> opcode is <code class='op'>ADD2</code>, modes can also be combined, for example: <code class='op'>ADD2r</code>.</p>

<p>The <b>return mode</b> makes it possible for any operator to operate on the return-stack directly, for that reason there is no return operation. For example, the JumpStash(<code class='op'>JSR</code>) operator pushes the program's address onto the return stash before jumping, to return to that address, the <code class='op'>JMPr</code> opcode is used, where instead of using the address on the working-stack, it takes its address directly from the return-stack.</p>

<pre>
#aa 
,subroutine JSR2 <span class='comment'>( jump, push addr* in return-stack )</span>
#cc

BRK

@subroutine
	#bb
	JMP2r <span class='comment'>( jump, pop addr* in return-stack )</span>
</pre>

<p>The <b>short mode</b> allows for each operator to do 16-bits operations by pushing and popping the necessary extra items from the stack. In the case of jump opcodes(<code class='op'>JMP2</code>, <code class='op'>JSR2</code>, and <code class='op'>JNZ2</code>) the short mode operation jumps to an absolute address in memory. For the getters and setters(<code class='op'>PEK2</code>, <code class='op'>POK2</code>, <code class='op'>LDR2</code> and <code class='op'>STR2</code>) the short mode operation will point to an absolute address in memory.</p>

<pre>
#1234 #5678 ADD2 <span class='comment'>( add two shorts )</span>
	#579b EQU2 <span class='comment'>( check if result is 0x579b )</span>

#1234 #0002 MUL2 
	#2468 EQU2

#0101 EQU2 <span class='comment'>( test both comparisons )</span>
</pre>

<h3>Runes</h3>

<table border='1'>
	<tr><th colspan='4'>Labels</th></tr>
	<tr><td><code>:variable { short 2 }</code></td><td>Assign memory allocation to a label.</td></tr>
	<tr><td><code>.label</code></td><td>Push label zero-page address to stack.</td></tr>
	<tr><td><code>,label</code></td><td>Push label relative address to stack.</td></tr>
	<tr><td><code>;label</code></td><td>Push label absolute address to stack.</td></tr>
	<tr><th colspan='2'>Define</th></tr>
	<tr><td><code>@label</code></td><td>Assign the current address to a label.</td></tr>
	<tr><td><code>$sublabel</code></td><td>Assign the current address to a local label.</td></tr>
	<tr><td><code>%macro { JMP2 POPr }</code></td><td>Define a macro.</td></tr>
	<tr><th colspan='2'>Program</th></tr>
	<tr><td><code>#01ab</code></td><td>Push a literal byte or short to stack.</td></tr>
	<tr><th colspan='2'>Helpers</th></tr>
	<tr><td><code>=label</code></td><td>Equivalent to <code>,label POK/STR</code>.</td></tr>
	<tr><td><code>~label</code></td><td>Equivalent to <code>,label POK/LDR</code>.</td></tr>
	<tr><th colspan='2'>Blocks</th></tr>
	<tr><td><code>( comment )</code></td><td>Toggle parsing on/off.</td></tr>
	<tr><td><code>[ 0123 abcd ]</code></td><td>write data to memory.</td></tr>
	<tr><th colspan='2'>Others</th></tr>
	<tr><td><code>|0010</code></td><td>Move to position in the program.</td></tr>
</table>


<p>For more flexbile transfer of data between the stacks and memory, there are 4 opcodes to read/write bytes and shorts:</p>

<table border='1'>

	<tr><th></th><th>input</th><th>output</th><th>opcode</th></tr>
	<tr><th rowspan="4">read</th><th rowspan="2">byte</th><th>byte</th><td><code>PEK</code></td></tr>
	<tr><th>short</th><td><code>LDR</code></td></tr>
	<tr><th rowspan="2">short</th><th>byte</th><td><code>PEK2</code></td></tr>
	<tr><th>short</th><td><code>LDR2</code></td></tr>
	<tr><th rowspan="4">write</th><th rowspan="2">byte</th><th>byte</th><td><code>POK</code></td></tr>
	<tr><th>short</th><td><code>STR</code></td></tr>
	<tr><th rowspan="2">short</th><th>byte</th><td><code>POK2</code></td></tr>
	<tr><th>short</th><td><code>STR2</code></td></tr>

</table>
<h2>Library</h2>

<pre>
%RTN   { JMP2r }
%STEP8 { #0033 SFT2 }
%MOD { DUP2 DIV MUL SUB }
%ABS { DUP #07 SHR #ff SWP MUL? }
%++ { #0001 ADD2 } %-- { #0001 SUB2 }
%2/ { #0001 SFT2 } %2* { #0010 SFT2 }
%8/ { #0003 SFT2 } %8* { #0030 SFT2 }
%8- { #0008 SUB2 } %8+ { #0008 ADD2 }
</pre>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:black; }
.clr3 { background:#ff0000; color:black; }
code.op { background: #ddd; color: black; font-size: smaller; display: inline-block; padding: 0px 2px; margin-right: 3px; }
pre span.comment { color:#666; }
</style>

<img src='../media/identity/uxn64.png' />
<figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/html/uxambly.htm' target='_blank'>edit</a> to <a href='../src/inc/html/uxambly.htm'>uxambly.htm</a>(221 lines)</figcaption>
</figure><ul><li><a href='https://git.sr.ht/~rabbits/uxn/tree/master/item/src/assembler.c' target='_blank'>assembler</a></li></ul><p><i>incoming(3)</i>: <a href='uxn.html'>uxn</a> <a href='roms.html'>roms</a> <a href='noodle.html'>noodle</a> </p><p><i>Last update on <a href='tracker.html'>15H10</a>, edited 16 times. +56/109fh <b></b></i> <code style='float:right; font-size:80%'>-----|</code></p></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> &copy; 2021 &mdash; <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>