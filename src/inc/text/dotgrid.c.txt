#include <SDL2/SDL.h>
#include <stdio.h>

/* 
Copyright (c) 2020 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

#define HOR 32
#define VER 16
#define PAD 8

#define PLIMIT 256
#define SZ (HOR * VER * 16)
#define PI 3.14159265358979323846

typedef struct {
	int x, y;
} Point2d;

typedef enum {
	POINT,
	LINE,
	ARC,
	BEZIER,
	RECTANGLE,
	ELLIPSE
} LineType;

typedef struct {
	int color, len;
	Point2d points[PLIMIT];
	LineType type;
} Path2d;

typedef struct {
	int len;
	Path2d paths[PLIMIT];
} Shape2d;

typedef struct Icon {
	unsigned short data[8];
} Icon;

Path2d stack;
Shape2d shape;
Point2d *selection;
int active = 0;

int theme[] = {0x000000, 0x72DEC2, 0xFFFFFF, 0x444444, 0xffb545};
int WIDTH = 8 * HOR + PAD * 2;
int HEIGHT = 8 * (VER + 2) + PAD * 2;
int FPS = 30, GUIDES = 1, COLOR = 3, ZOOM = 2;
SDL_Window *gWindow = NULL;
SDL_Renderer *gRenderer = NULL;
SDL_Texture *gTexture = NULL;
Uint32 *pixels;

/* Icons */

unsigned char icon0[] = {0x38, 0x7c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x00};
unsigned char icon1[] = {0x38, 0x44, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00};
unsigned char icon2[] = {0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00};
unsigned char icon3[] = {0x06, 0x18, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00};
unsigned char icon4[] = {0x02, 0x02, 0x04, 0x38, 0x40, 0x80, 0x80, 0x00};

/* helpers */

Point2d *
setpt2d(Point2d *p, int x, int y)
{
	p->x = x;
	p->y = y;
	return p;
}

Point2d
Pt2d(int x, int y)
{
	Point2d p;
	setpt2d(&p, x, y);
	return p;
}

Point2d
lerp2d(Point2d a, Point2d b, int seg, int segs)
{
	double segx = (b.x - a.x) / (double)segs;
	double segy = (b.y - a.y) / (double)segs;
	return Pt2d(a.x + segx * seg, a.y + segy * seg);
}

int
equpt2d(Point2d *a, Point2d *b)
{
	return a->x == b->x && a->y == b->y;
}

Path2d *
cpypath2d(Path2d *src, Path2d *dst)
{
	int i;
	dst->len = src->len;
	for(i = 0; i < dst->len; ++i)
		setpt2d(&dst->points[i], src->points[i].x, src->points[i].y);
	return dst;
}

int
cpos(char *s, char c)
{
	int i = 0;
	while(s[i] && s[i])
		if(s[i++] == c)
			return i - 1;
	return -1;
}

int
slen(char *s)
{
	int i = 0;
	while(s[i] && s[++i])
		;
	return i;
}

int
scmp(char *a, char *b)
{
	int i = 0;
	while(a[i] == b[i])
		if(!a[i++])
			return 1;
	return 0;
}

int
sint(char *s, int len)
{
	int num = 0, i = 0;
	while(s[i] && i < len && (s[i] >= '0' && s[i] <= '9'))
		num = num * 10 + (s[i++] - '0');
	return num;
}

unsigned char
chex(char c)
{
	if(c >= 'a' && c <= 'f')
		return 10 + c - 'a';
	if(c >= 'A' && c <= 'F')
		return 10 + c - 'A';
	return (c - '0') & 0xF;
}

int
shex(char *s, int len)
{
	int i, n = 0;
	for(i = 0; i < len; ++i)
		n |= (chex(s[i]) << ((len - i - 1) * 4));
	return n;
}

int
cancast(LineType type)
{
	if(type == POINT && stack.len >= 1)
		return 1;
	else if(type == LINE && stack.len >= 2)
		return 1;
	else if(type == RECTANGLE && stack.len >= 2)
		return 1;
	else if(type == ELLIPSE && stack.len >= 2)
		return 1;
	else if(type == ARC && stack.len >= 3)
		return 1;
	else if(type == BEZIER && stack.len >= 3)
		return 1;
	return 0;
}

/* draw */

void
clear(Uint32 *dst)
{
	int i, j;
	for(i = 0; i < HEIGHT; i++)
		for(j = 0; j < WIDTH; j++)
			dst[i * WIDTH + j] = theme[0];
}

void
pixel(Uint32 *dst, int x, int y, int color)
{
	if(x >= 0 && x < WIDTH - 8 && y >= 0 && y < HEIGHT - 8)
		dst[(y + PAD) * WIDTH + (x + PAD)] = color;
}

void
line(Uint32 *dst, int ax, int ay, int bx, int by, int color)
{
	int dx = abs(bx - ax), sx = ax < bx ? 1 : -1;
	int dy = -abs(by - ay), sy = ay < by ? 1 : -1;
	int err = dx + dy, e2;
	for(;;) {
		pixel(dst, ax, ay, color);
		if(ax == bx && ay == by)
			break;
		e2 = 2 * err;
		if(e2 >= dy) {
			err += dy;
			ax += sx;
		}
		if(e2 <= dx) {
			err += dx;
			ay += sy;
		}
	}
}

void
ellipse(Uint32 *dst, int x0, int y0, int x1, int y1, int cadran, int color)
{
	int a = abs(x1 - x0), b = abs(y1 - y0), b1 = b & 1;
	int dx = 4 * (1.0 - a) * b * b, dy = 4 * (b1 + 1) * a * a;
	int err = dx + dy + b1 * a * a, e2;
	if(x0 > x1) {
		x0 = x1;
		x1 += a;
	}
	if(y0 > y1)
		y0 = y1;
	y0 += (b + 1) >> 1;
	y1 = y0 - b1;
	a = 8 * a * a;
	b1 = 8 * b * b;
	do {
		if(cadran == -1 || cadran == 1)
			pixel(dst, x1, y0, color);
		if(cadran == -1 || cadran == 2)
			pixel(dst, x0, y0, color);
		if(cadran == -1 || cadran == 3)
			pixel(dst, x0, y1, color);
		if(cadran == -1 || cadran == 0)
			pixel(dst, x1, y1, color);
		e2 = 2 * err;
		if(e2 <= dy) {
			y0++;
			y1--;
			err += dy += a;
		}
		if(e2 >= dx || 2 * err > dy) {
			x0++;
			x1--;
			err += dx += b1;
		}
	} while(x0 <= x1);
}

void
arc(Uint32 *dst, int x0, int y0, int x1, int y1, int x2, int y2, int color)
{
	int cadran, col = (y1 - y0) * (x2 - x1) - (y2 - y1) * (x1 - x0);
	x1 = x2;
	y1 = y2;
	if(x2 > x0 && y2 > y0) {
		if(col < 0) {
			x0 = x0 - (x2 - x0);
			y1 = y2 + (y2 - y0);
			cadran = 0;
		} else {
			y0 = y0 - (y2 - y0);
			x1 = x2 + (x2 - x0);
			cadran = 2;
		}
	} else if(x2 < x0 && y2 > y0) {
		if(col < 0) {
			y0 = y0 - (y2 - y0);
			x1 = x2 + (x2 - x0);
			cadran = 1;
		} else {
			x0 = x0 - (x2 - x0);
			y1 = y2 + (y2 - y0);
			cadran = 3;
		}
	} else if(x2 < x0 && y2 < y0) {
		if(col < 0) {
			x0 = x0 - (x2 - x0);
			y1 = y2 + (y2 - y0);
			cadran = 2;
		} else {
			y0 = y0 - (y2 - y0);
			x1 = x2 + (x2 - x0);
			cadran = 0;
		}
	} else {
		if(col < 0) {
			y0 = y0 - (y2 - y0);
			x1 = x2 + (x2 - x0);
			cadran = 3;
		} else {
			x0 = x0 - (x2 - x0);
			y1 = y2 + (y2 - y0);
			cadran = 1;
		}
	}
	ellipse(dst, x0, y0, x1, y1, cadran, color);
}

void
rectangle(Uint32 *dst, int x0, int y0, int x1, int y1, int color)
{
	line(dst, x0, y0, x0, y1, color);
	line(dst, x0, y1, x1, y1, color);
	line(dst, x1, y1, x1, y0, color);
	line(dst, x1, y0, x0, y0, color);
}

void
handle(Uint32 *dst, int x0, int y0, int r, int color)
{
	line(dst, x0, y0 - r, x0 + r, y0, color);
	line(dst, x0 + r, y0, x0, y0 + r, color);
	line(dst, x0, y0 + r, x0 - r, y0, color);
	line(dst, x0 - r, y0, x0, y0 - r, color);
}

void
bezier(Uint32 *dst, int x0, int y0, int x1, int y1, int x2, int y2, int color)
{
	int i, segs = 8;
	Point2d prev = Pt2d(x0, y0);
	for(i = 0; i <= segs; i++) {
		Point2d a = lerp2d(Pt2d(x0, y0), Pt2d(x1, y1), i, segs);
		Point2d b = lerp2d(Pt2d(x1, y1), Pt2d(x2, y2), i, segs);
		Point2d c = lerp2d(a, b, i, segs);
		line(dst, prev.x, prev.y, c.x, c.y, color);
		prev = c;
	}
}

void
drawpath(Uint32 *dst, Path2d *path, int guides)
{
	int j;
	/* Draw paths */
	for(j = 0; j < path->len; ++j) {
		Point2d *a = &path->points[j];
		if(j < path->len - 1) {
			Point2d *b = &path->points[j + 1];
			if(path->type == LINE)
				line(dst, a->x, a->y, b->x, b->y, theme[path->color]);
			else if(path->type == RECTANGLE)
				rectangle(dst, a->x, a->y, b->x, b->y, theme[path->color]);
			else if(path->type == ELLIPSE)
				ellipse(dst, a->x, a->y, b->x, b->y, -1, theme[path->color]);
		}
		if(j < path->len - 2) {
			Point2d *b = &path->points[j + 1];
			Point2d *c = &path->points[j + 2];
			if(path->type == ARC)
				arc(dst, a->x, a->y, b->x, b->y, c->x, c->y, theme[path->color]);
			else if(path->type == BEZIER)
				bezier(dst, a->x, a->y, b->x, b->y, c->x, c->y, theme[path->color]);
			if(path->type == ARC || path->type == BEZIER)
				j++;
		}
		if(path->type == POINT)
			pixel(dst, a->x, a->y, theme[path->color]);
	}

	for(j = 0; j < path->len; ++j) {
		Point2d *a = &path->points[j];
		if(guides)
			handle(dst, a->x, a->y, 2, theme[4]);
	}
}

void
drawguides(Uint32 *dst, int step)
{
	int x, y;
	for(x = 2; x < WIDTH - 16; x++)
		for(y = 2; y < HEIGHT - 32; y++) {
			if(x % (step * 2) == y % (step * 2) && x % (step * 2) == 0)
				pixel(dst, x, y, theme[2]);
			else if(x % step == 0 && y % 2 == 0)
				pixel(dst, x, y, theme[3]);
			else if(y % step == 0 && x % 2 == 0)
				pixel(dst, x, y, theme[3]);
		}
}

void
drawicon(Uint32 *dst, int x, int y, unsigned char *icon, int color)
{
	int v, h;
	for(v = 0; v < 8; v++)
		for(h = 0; h < 8; h++) {
			int c = theme[(icon[v] >> (8 - h)) & 0x1];
			pixel(dst, x + h, y + v, c ? color : theme[0]);
		}
}

void
drawui(Uint32 *dst)
{
	int clr = active >= 0 ? shape.paths[active].color : 1;
	int bottom = VER * 8 + 8;
	drawicon(dst, 0, bottom, clr == 1 ? icon1 : icon0, theme[1]);
	drawicon(dst, 1 * 8, bottom, clr == 2 ? icon1 : icon0, theme[2]);
	drawicon(dst, 2 * 8, bottom, clr == 3 ? icon1 : icon0, theme[3]);

	drawicon(dst, 4 * 8, bottom, icon2, theme[cancast(LINE) ? 2 : 3]);
	drawicon(dst, 5 * 8, bottom, icon3, theme[cancast(ARC) ? 2 : 3]);
	drawicon(dst, 6 * 8, bottom, icon4, theme[cancast(BEZIER) ? 2 : 3]);
}

void
redraw(Uint32 *dst)
{
	int i;
	clear(dst);
	if(GUIDES)
		drawguides(dst, 16);
	/* draw shape */
	for(i = 0; i < shape.len; i++)
		drawpath(dst, &shape.paths[i], GUIDES && active == i);
	/* draw stack */
	for(i = 0; i < stack.len; ++i) {
		Point2d *a = &stack.points[i];
		handle(dst, a->x, a->y, 2, theme[4]);
		if(i < stack.len - 1) {
			Point2d *b = &stack.points[i + 1];
			line(dst, a->x, a->y, b->x, b->y, theme[4]);
		}
	}
	drawui(dst);
	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(Uint32));
	SDL_RenderClear(gRenderer);
	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);
	SDL_RenderPresent(gRenderer);
}

/* options */

int
error(char *msg, const char *err)
{
	printf("Error %s: %s\n", msg, err);
	return 0;
}

void
modzoom(int mod)
{
	if((mod > 0 && ZOOM < 4) || (mod < 0 && ZOOM > 1)) {
		ZOOM += mod;
		SDL_SetWindowSize(gWindow, WIDTH * ZOOM, HEIGHT * ZOOM);
	}
}

void
addpoint(Point2d touch)
{
	if(stack.len > 0 && equpt2d(&touch, &stack.points[stack.len - 1]))
		return;
	stack.points[stack.len++] = touch;
	redraw(pixels);
}

void
selectpoint(Point2d *touch)
{
	int i, j;
	selection = NULL;
	for(i = 0; i < shape.len; ++i) {
		Path2d *p = &shape.paths[i];
		for(j = 0; j < p->len; ++j)
			if(equpt2d(touch, &p->points[j])) {
				selection = &p->points[j];
				active = i;
				redraw(pixels);
				break;
			}
	}
}

void
dragpoint(Point2d *touch)
{
	if(equpt2d(touch, selection))
		return;
	setpt2d(selection, touch->x, touch->y);
	stack.len = 0;
	redraw(pixels);
}

void
cancel(void)
{
	active = shape.len - 1;
	stack.len = 0;
	redraw(pixels);
}

void
cast(LineType type)
{
	if(!cancast(type))
		return;
	cpypath2d(&stack, &shape.paths[shape.len]);
	shape.paths[shape.len].color = COLOR;
	shape.paths[shape.len++].type = type;
	cancel();
	printf("Casted %d(%d)\n", type, shape.len);
}

void
erase(void)
{
	if(stack.len > 0)
		stack.len = 0;
	else if(shape.len > 0)
		shape.len--;
	cancel();
}

void
destroy(void)
{
	shape.len = 0;
	cancel();
	puts("Destroy");
}

void
setcolor(int c)
{
	if(active >= 0)
		shape.paths[active].color = c;
	COLOR = c;
	redraw(pixels);
	printf("Selected Color %d\n", c);
}

void
toggleguide(void)
{
	GUIDES = !GUIDES;
	redraw(pixels);
	printf("%s Guides\n", GUIDES ? "Show" : "Hide");
}

void
renderbmp(void)
{
	SDL_Surface *surface = SDL_GetWindowSurface(gWindow);
	SDL_RenderReadPixels(gRenderer,
		NULL,
		SDL_PIXELFORMAT_ARGB8888,
		surface->pixels,
		surface->pitch);
	if(SDL_SaveBMP(surface, "dotgrid-render.bmp"))
		printf("SDL_SaveBMP failed: %s\n", SDL_GetError());
	else
		puts("Rendered dotgrid-render.bmp");
	SDL_FreeSurface(surface);
}

void
savetxt(void)
{
	int i, j, c = -1;
	FILE *f = fopen("dotgrid-shape.txt", "w");
	char *names[6] = {
		"point",
		"line",
		"arc",
		"bezier",
		"rectangle",
		"ellipse"};
	for(i = 0; i < shape.len; ++i) {
		Path2d *p = &shape.paths[i];
		if(c != p->color) {
			fprintf(f, "%d setcolor\n", p->color);
			c = p->color;
		}
		for(j = 0; j < p->len; ++j)
			fprintf(f, "%d,%d ", p->points[j].x, p->points[j].y);
		fprintf(f, "%s\n", names[(int)p->type]);
	}
	fclose(f);
	puts("Saved dotgrid-shape.txt");
}

void
loadtxt(FILE *f)
{
	char line[256], query[256];
	int i = 0, querylen = 0, setting = 0;
	if(!f)
		return;
	while(fgets(line, 256, f)) {
		if(line[0] == ';')
			continue;
		i = 0;
		while(line[i]) {
			if(line[i] == ' ' || line[i] == '\n' || !line[i]) {
				int c = cpos(query, ',');
				if(c >= 0)
					addpoint(Pt2d(
						sint(query, c),
						sint(query + c + 1, slen(query) - c - 1)));
				else if(i > 0 && scmp(query, "setcolor"))
					COLOR = setting;
				else if(scmp(query, "line"))
					cast(LINE);
				else if(scmp(query, "arc"))
					cast(ARC);
				else if(scmp(query, "bezier"))
					cast(BEZIER);
				else if(scmp(query, "point"))
					cast(POINT);
				else if(scmp(query, "rectangle"))
					cast(RECTANGLE);
				else if(scmp(query, "ellipse"))
					cast(ELLIPSE);
				else if(slen(query) == 1)
					setting = query[0] - '0';
				querylen = 0;
				query[0] = '\0';
			} else {
				query[querylen++] = line[i];
				query[querylen] = '\0';
			}
			i++;
		}
	}
	fclose(f);
}

void
loadtheme(FILE *f)
{
	int id = 0;
	char line[256];
	if(!f)
		return;
	while(fgets(line, 256, f)) {
		int i = 0;
		while(line[i++]) {
			if(line[i] != '#')
				continue;
			if(id == 0 || id > 4)
				theme[id > 4 ? id - 4 : 0] = shex(line + i + 1, 6);
			id++;
		}
	}
	fclose(f);
}

void
selectoption(int option)
{
	switch(option) {
	case 0: setcolor(1); break;
	case 1: setcolor(2); break;
	case 2: setcolor(3); break;
	case 4: cast(LINE); break;
	case 5: cast(ARC); break;
	case 6: cast(BEZIER); break;
	}
}

void
quit(void)
{
	free(pixels);
	SDL_DestroyTexture(gTexture);
	gTexture = NULL;
	SDL_DestroyRenderer(gRenderer);
	gRenderer = NULL;
	SDL_DestroyWindow(gWindow);
	gWindow = NULL;
	SDL_Quit();
	exit(0);
}

void
domouse(SDL_Event *event)
{
	Point2d clamped, touch = Pt2d(
						 (event->motion.x - (PAD * ZOOM)) / ZOOM,
						 (event->motion.y - (PAD * ZOOM)) / ZOOM);
	setpt2d(&clamped, touch.x, touch.y);
	setpt2d(&clamped,
		abs((touch.x + 8 / 2) / 8) * 8,
		abs((touch.y + 8 / 2) / 8) * 8);
	switch(event->type) {
	case SDL_MOUSEBUTTONUP:
		if(clamped.y >= VER * 8)
			; /* interface */
		else if(selection && !equpt2d(&clamped, selection))
			dragpoint(&clamped);
		else if(active == shape.len - 1)
			addpoint(clamped);
		selection = NULL;
		break;
	case SDL_MOUSEBUTTONDOWN:
		if(clamped.y >= VER * 8)
			selectoption(abs(touch.x / 8));
		else
			selectpoint(&clamped);
		break;
	case SDL_MOUSEMOTION:
		break;
	}
}

void
dokey(SDL_Event *event)
{
	switch(event->key.keysym.sym) {
	case SDLK_EQUALS:
	case SDLK_PLUS: modzoom(1); break;
	case SDLK_UNDERSCORE:
	case SDLK_MINUS: modzoom(-1); break;
	case SDLK_ESCAPE: cancel(); break;
	case SDLK_BACKSPACE: erase(); break;
	case SDLK_r: renderbmp(); break;
	case SDLK_t: savetxt(); break;
	case SDLK_a: cast(LINE); break;
	case SDLK_s: cast(ARC); break;
	case SDLK_d: cast(BEZIER); break;
	case SDLK_z: cast(POINT); break;
	case SDLK_x: cast(RECTANGLE); break;
	case SDLK_c: cast(ELLIPSE); break;
	case SDLK_1: setcolor(1); break;
	case SDLK_2: setcolor(2); break;
	case SDLK_3: setcolor(3); break;
	case SDLK_h: toggleguide(); break;
	case SDLK_n: destroy(); break;
	}
}

int
init(void)
{
	if(SDL_Init(SDL_INIT_VIDEO) < 0)
		return error("Init", SDL_GetError());
	gWindow = SDL_CreateWindow("Dotgrid",
		SDL_WINDOWPOS_UNDEFINED,
		SDL_WINDOWPOS_UNDEFINED,
		WIDTH * ZOOM,
		HEIGHT * ZOOM,
		SDL_WINDOW_SHOWN);
	if(gWindow == NULL)
		return error("Window", SDL_GetError());
	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);
	if(gRenderer == NULL)
		return error("Renderer", SDL_GetError());
	gTexture = SDL_CreateTexture(gRenderer,
		SDL_PIXELFORMAT_ARGB8888,
		SDL_TEXTUREACCESS_STATIC,
		WIDTH,
		HEIGHT);
	if(gTexture == NULL)
		return error("Texture", SDL_GetError());
	pixels = (Uint32 *)malloc(WIDTH * HEIGHT * sizeof(Uint32));
	if(pixels == NULL)
		return error("Pixels", "Failed to allocate memory");
	clear(pixels);
	return 1;
}

int
main(int argc, char *argv[])
{
	int ticknext = 0;

	if(!init())
		return error("Init", "Failure");

	loadtheme(fopen("theme.svg", "r"));

	if(argc > 1)
		loadtxt(fopen(argv[1], "r"));
	cancel();

	while(1) {
		int tick = SDL_GetTicks();
		SDL_Event event;
		if(tick < ticknext)
			SDL_Delay(ticknext - tick);
		ticknext = tick + (1000 / FPS);
		while(SDL_PollEvent(&event) != 0) {
			if(event.type == SDL_QUIT)
				quit();
			else if(event.type == SDL_MOUSEBUTTONUP ||
					event.type == SDL_MOUSEBUTTONDOWN ||
					event.type == SDL_MOUSEMOTION) {
				domouse(&event);
			} else if(event.type == SDL_KEYDOWN)
				dokey(&event);
			else if(event.type == SDL_WINDOWEVENT)
				if(event.window.event == SDL_WINDOWEVENT_EXPOSED)
					redraw(pixels);
		}
	}
	quit();
	return 0;
}
