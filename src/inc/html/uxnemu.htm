<p>Devices are external systems to the Uxn code such as the screen, the mouse, the keyboard, etc. There is a maximum of 16 devices, each device have 8 bytes to read from, and 8 bytes to write to.</p>

<h2>Devices</h2>

<p>An emulator implementation can choose which device to implement or to leave out, these are the suggested addresses and ports of this specific emulator.</p>

<table border='1'>
	<tr><th rowspan='2' colspan='2'>device</th><th colspan='2'>i/o</th><th rowspan="2">Notes</th></tr>
	<tr><th>0x00</th><th>0x08</th></tr>

	<tr><th rowspan='3'><code>0100</code></th><th rowspan='3'>system</th><td class='clr2'>vector*</td><td class='clr1'>red*</td><td rowspan="3">The system device's vector is automatically set by the emulator and is the first vector that is triggered in a program.</td></tr>
	<tr><td rowspan="2"></td><td class='clr1'>green*</td></tr>
	<tr><td class='clr1'>blue*</td></tr>

	<tr><th rowspan='4'><code>0110</code></th><th rowspan='4'>console</th><td class='clr3'>vector*</td><td class='clr1'>char</td><td rowspan="4">The console's vector is currently unused.</td></tr>
	<tr><td rowspan='3'></td><td class='clr1'>byte</td></tr>
	<tr><td class='clr1'>short*</td></tr>
	<tr><td class='clr1'>string*</td></tr>

	<tr><th rowspan='4'><code>0120</code></th><th rowspan='4'><a href='#screen'>screen</a></th><td class='clr2'>vector*</td><td>x*</td><td rowspan="4">The screen device's vector is triggered 60 times per second, it is typically used to update pixels on the screen.</td></tr>
	<tr><td>width*</td><td>y*</td></tr>
	<tr><td>height*</td><td>addr*</td></tr>
	<tr><td></td><td class='clr1'>color</td></tr>

	<tr><th rowspan='6'><code>0130</code></th><th rowspan='6'><a href='#audio'>audio</a></th><td class='clr2'>wave*</td><td>volume</td><td rowspan="6">The APU multiplies two waveforms, defined by the wave and envelope vectors. In the main program, write the vectors, volume (left/right nibbles) and pitch (MIDI note number) to define the note, then the channel number to the play byte.</td></tr>
	<tr><td class='clr2'>envelope*</td><td>pitch</td></tr>
	<tr><td rowspan="4"></td><td class='clr1'>play</td></tr>
	<tr><td>value*</td></tr>
	<tr><td class='clr1'>delay*</td></tr>
	<tr><td class='clr1'>finish</td></tr>

	<tr><th rowspan="5"><code>0140</code></th><th rowspan="5">controller</th><td class='clr2'>vector*</td><td rowspan="5"><i>nil</i></td><td rowspan="5">The controller device's vector is triggered each time a button is pressed or released.</td></tr>
	<tr><td>player1</td></tr>
	<tr><td>player2</td></tr>
	<tr><td>player3</td></tr>
	<tr><td>player4</td></tr>

	<tr><th rowspan="2"><code>0150</code></th><th rowspan="2">keyboard</th><td class='clr2'>vector*</td><td rowspan="2"><i>nil</i></td><td rowspan="2">The keyboard device's vector is triggered each time a character is typed.</td></tr>
	<tr><td>key</td></tr>

	<tr><th rowspan='5'><code>0160</code></th><th rowspan='5'>mouse</th><td class='clr2'>vector*</td><td rowspan="5"><i>nil</i></td><td rowspan="5">The mouse device's vector is triggered each time the mouse moved, or a button was pressed or released.</td></tr>
	<tr><td>x*</td></tr>
	<tr><td>y*</td></tr>
	<tr><td>state</td></tr>
	<tr><td>chord</td></tr>

	<tr><th rowspan='4'><code>0170</code></th><th rowspan='4'>file</th><td class='clr2'>vector*</td><td>name*</td><td rowspan="4">The file device's vector is triggered on file read/write success.</td></tr>
	<tr><td rowspan="3"></td><td>length*</td></tr>
	<tr><td class='clr1'>addr(r)*</td></tr>
	<tr><td class='clr1'>addr(w)*</td></tr>
	
	<tr><th rowspan='4'><code>0190</code></th><th rowspan='4'>midi</th><td class='clr2'>vector*</td><td>devicew</td><td rowspan="4">The midi device's vector is triggered when a midi note is received.</td></tr>
	<tr><td>devicer</td><td>byte1</td></tr>
	<tr><td>byte1</td><td>byte2</td></tr>
	<tr><td>byte2</td></tr>

	<tr><th rowspan='4'><code>01a0</code></th><th rowspan='4'>datetime</th><td>yearh*</td><td class='clr1'>refresh</td><td rowspan="4">The datetime's vector is currently unused.</td></tr>
	<tr><td>yearl*</td><td rowspan="3"></td></tr>
	<tr><td>dayh*</td></tr>
	<tr><td>dayl*</td></tr>
</table>

<h3 id='screen'>Screen Device(PPU)</h3>

<table border='1'>
	<tr><th rowspan="2">Buffers</th><td>background</td><td>64kb</td></tr>
	<tr><td>foreground</td><td>64kb</td></tr>
</table>

<p>The screen device is made of two screen buffers, that are combined to form the pixels on the screen. The sprite device can be written to with a <code>x*</code>, <code>y*</code> and <code>color</code>.</p>
<p>The <b>color byte</b> defines the layer to draw on, the type of data to draw, and the colors to use. To paint a pixel on the first layer, use the <code>#01</code>, to paint a pixel on the second layer, use the <code>#11</code>.</p>

<pre>
* * M L            D C B A            
| | | +---- Layer  | | | +---- Blend   
| | +------ Mode   | | +------ Blend   
| +-------- Nil    | +-------- Blend  
+---------- Nil    +---------- Blend  
</pre>

<p>The device can also draw multiple bytes at once by writing the address* to a series of bytes in the screen's sprite address, to paint a 1-bit 8x8 sprite(8 bytes) on the first layer, use the <code>#21</code>, to paint a 1-bit 8x8 sprite on the second layer, use the <code>#31</code>. The blending mode 1, is demonstrated in the table below. To learn more about the sprite format, see <a href='chr_format.html'>.chr format</a>.</p>

<table border='1'>
	<tr><th colspan='3'>high nibble</th><th colspan='6'>low nibble</th></tr>
	<tr><th>0</th><td>bg</td><td rowspan='2'>pixel</td><th>0</th><td class='clr0' colspan='2'>0</td><th>8</th><td class='clr0'>0</td><td class='clr2'>2</td></tr></tr>
	<tr><th>1</th><td>fg</td><th>1</th><td class='clr1'>1</td><td class='clr0'>0</td><th>9</th><td class='clr1'>1</td><td class='clr2'>2</td></tr></tr>
	<tr><th>2</th><td>bg</td><td rowspan='2'>1-bit</td><th>2</th><td class='clr2'>2</td><td class='clr0'>0</td><th>a</th><td class='clr2' colspan='2'>2</td></tr></tr>
	<tr><th>3</th><td>fg</td><th>3</th><td class='clr3'>3</td><td class='clr0'>0</td><th>b</th><td class='clr3'>3</td><td class='clr2'>2</td></tr></tr>
	<tr><th>4</th><td>bg</td><td rowspan='2'>2-bit</td><th>4</th><td class='clr0'>0</td><td class='clr1'>1</td><th>c</th><td class='clr0'>0</td><td class='clr3'>3</td></tr></tr>
	<tr><th>5</th><td>fg</td><th>5</th><td class='clr1' colspan='2'>1</td><th>d</th><td class='clr1'>1</td><td class='clr3'>3</td></tr></tr>
	<tr><th>6</th><td>bg</td><td rowspan='2'><i>nil</i></td><th>6</th><td class='clr2'>2</td><td class='clr1'>1</td><th>e</th><td class='clr2'>2</td><td class='clr3'>3</td></tr></tr>
	<tr><th>7</th><td>fg</td><th>7</th><td class='clr3'>3</td><td class='clr1'>1</td><th>f</th><td class='clr3' colspan='2'>3</td></tr></tr>
</table>

<h3 id='audio'>Audio Device(APU)</h3>

<p>In the wave and envelope vectors, write the value (amplitude) and delay shorts to define the next part of the waveform. A delay of <code>0x8000</code> in the wave vector represents half the note's period: in the envelope vector, it represents half a second. The waveform is linearly interpolated between pairs of values. During these vectors, the channel number used for the note can be read from the play byte.</p>

<p>The wave and envelope vectors repeat until (a) no value/delay pairs are written to the device or (b) any value is written to the finish byte.</p>

<h3>Controller Device</h3>

<p>This device works like a NES controller, each one of the 8 buttons is a bit from a single byte. To check if the up button is pressed:</p>

<table border='1'>
	<tr><td><code>0x01</code></td><td>Ctrl</td><td><code>0x10</code></td><td>Up</td></tr>
	<tr><td><code>0x02</code></td><td>Alt</td><td><code>0x20</code></td><td>Down</td></tr>
	<tr><td><code>0x04</code></td><td>Backspace</td><td><code>0x40</code></td><td>Left</td></tr>
	<tr><td><code>0x08</code></td><td>Return</td><td><code>0x80</code></td><td>Right</td></tr>
</table>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:black; }
.clr3 { background:#ff0000; color:black; }
</style>

<img src='../media/identity/uxn64.png' />