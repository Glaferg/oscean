<h3>The Accumulator</h3>

<p>The <b>state of the accumulator</b> is held as a single number, whose prime factorization holds these registers(2, 3, 5, 7, 11, 13, 17, ..). If the state of the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value 2, r7 has the value 1, and all other registers are unassigned. </p>

<table border='1'>
	<tr><th>accumulator</th><th colspan='4'>registers</th></tr>
	<tr><th></th><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<h3>The Operators</h3>

<p>A fractran operation is a positive fraction, each fraction represents an instruction that tests one or more registers, represented by the prime factors of its denominator. The Fractran computer goes through each fraction in order, in terms of our current accumulator value.</p>

<img src='../media/refs/fractran.adder2.jpg' width='160px'/>

<p>For example, to run the <i>adder operation</i>(<code>2/3</code>), we will take the state of the accumulator. If multiplying it by this fraction will give us an integer, we will do so and start again at the beginning of the program. Otherwise, we will stop and consider the program complete. We will do this repeatedly until we can no longer produce an integer with this method. </p>

<table border='1'>
	<tr><th rowspan='2'>steps</th><th rowspan='2'>state</th><th colspan='2'>registers</th></tr>
	<tr><th>r2</th><th>r3</th></tr>
	<tr style='background:#eee'><td>1</td><th>18</th><td>1</td><td>2</td><td>18 × 2/3 = 12/1</td><td>INT, RESTART</td></tr>
	<tr><td>2</td><th>12</th><td>2</td><td>1</td><td>12 × 2/3 = 8/1</td><td>INT, RESTART</td></tr>
	<tr><td>3</td><th>8</th><td>3</td><td></td><td>8 × 2/3 = 16/3</td><td>NOT INT, END</td></tr>
</table>

<p>To add the values 1 and 2, we will store the values in registers 2 and 3, our starting state is therefore 18(2<sup>1</sup> × 3<sup>2</sup>). For each step of the program, we will multiply our state with the program(18 × 2/3 = 12, 12 × 2/3 = 8, ..) until our our working value cannot be reduced to a whole number(16/3), we have exhausted the program. Alternatively, the program <code>3/2</code> will do the same operation but store the result in the register 3.</p>

<p>Operations become more readable when broken down into their primes. We can think of every prime number as having a register which can take on non-negative integer values. Each fraction is an instruction that operates on some of the registers.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>9/2</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(2<sup>1</sup>)/(3<sup>1</sup>)</td>
		<td>(3<sup>2</sup>)/(2<sup>1</sup>)</td>
		<td>(3<sup>1</sup> × 7<sup>1</sup>)/(2<sup>2</sup> × 5<sup>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(r3 >= 1){ 
	r3 -= 1;
	r2 += 1;
	return;
}</pre>
		</td>
		<td>
<pre>
if(r2 >= 1){ 
	r2 -= 1;
	r3 += 2;
	return;
}</pre>
		</td>
		<td>
<pre>
if(r2 >= 2 && r5 >= 1){ 
	r2 -= 2; r5 -= 1; 
	r3 += 1; r7 += 1;
	return;
}</pre>
		</td>
	</tr>
</table>

<p>You can interpret a fraction as saying if the current value of each register is greater than or equal to the the value specified by the denominator, you subtract from the registers all of the values in the denominator, add all the values specified in the numerator, and then jump back to the first instruction. Otherwise, if any register is less than the value specified in the denominator, continue to the next fraction.</p>

<h3>Tools</h3>

<p>A simple <a href='ansi_c'>C</a> function to print the exponential factors of a number, or the value stored in the registers.</p>

<pre>
void
printregisters(int num)
{
	int fac = 2;
	while(num > 1) {
		if(num % fac == 0) {
			int pow = 1;
			printf("r%02d=", fac);
			num /= fac;
			while(!(num % fac)) {
				num /= fac;
				pow++;
			}
			printf("%d", pow);
			if(num != 1)
				putchar(' ');
		} else
			fac++;
	}
}
</pre>
