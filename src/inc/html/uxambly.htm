<h2>Opcodes</h2>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 are used to select modes of that opcode, modes are explained below.</p>

<table border='1'>
	<tr><td colspan='3'>mode</td><td colspan='5'>opcode</td></tr>
	<tr><td><i>nil</i></td><td>return<code>[r]</code></td><td>short<code>[2]</code></td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<p>Opcodes using memory addresses can pop 2 bytes at once to form an absolute address, or a single one to create a relative address in the case of jump opcodes, or a the zero-page address in the case of peek/poke opcodes. For example, if <code>[0xAB 0xCD]</code> is present on the stack, it will be used by <code>JMP2</code> to point to the memory address <code>0xABCD</code>.</p>

<table border='1' width='700'>
	<tr><td></td><th colspan='3'>Stack</th><td></td>                                          <th colspan='3'>Memory</th></tr>
	<tr><th>0x00</th><td><code class='op'>BRK</code> Break</td><td></td><td></td>             <th>0x10</th><td><code class='op'>PEK</code> LoadByte</td><td>[a]</td><td>b</td></tr>
	<tr><th>0x01</th><td><code class='op'>LIT</code> Literal</td><td>-></td><td></td>         <th>0x11</th><td><code class='op'>POK</code> StoreByte</td><td>a [b]</td><td></td></tr>
	<tr><th>0x02</th><td><code class='op'>IND</code> Indirect</td><td>-></td><td></td>        <th>0x12</th><td><code class='op'>LDR</code> LoadShort</td><td>[a]</td><td>c</td></tr>
	<tr><th>0x03</th><td><code class='op'>POP</code> Pop</td><td>a</td><td></td>              <th>0x13</th><td><code class='op'>STR</code> StoreShort</td><td>a [b]</td><td></td></tr>
	<tr><th>0x04</th><td><code class='op'>DUP</code> Duplicate</td><td>a</td><td>a a</td>     <th>0x14</th><td><code class='op'>JMP</code> Jump</td><td>[a]</td><td></tr>
	<tr><th>0x05</th><td><code class='op'>SWP</code> Swap</td><td>a b</td><td>b a</td>        <th>0x15</th><td><code class='op'>JNZ</code> JumpCond</td><td>a [b]</td><td></td></tr>
	<tr><th>0x06</th><td><code class='op'>OVR</code> Over</td><td>a b</td><td>a b a</td>      <th>0x16</th><td><code class='op'>JSR</code> JumpStash</td><td>[a]</td><td>rs</td></tr>
	<tr><th>0x07</th><td><code class='op'>ROT</code> Rotate</td><td>a b c</td><td>b c a</td>  <th>0x17</th><td><code class='op'>STH</code> Stash</td><td>a</td><td>rs</td></tr>
	<tr><td></td><th colspan='3'>Logic</th><td></td>                                          <th colspan='3'>Arithmetic</th></tr>
	<tr><th>0x08</th><td><code class='op'>EQU</code> Equal</td><td>a b</td><td>c</td>         <th>0x18</th><td><code class='op'>ADD</code> Add</td><td>a b</td><td>c</td></tr>
	<tr><th>0x09</th><td><code class='op'>NEQ</code> NotEqual</td><td>a b</td><td>c</td>      <th>0x19</th><td><code class='op'>SUB</code> Subtract</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0a</th><td><code class='op'>GTH</code> GreaterThan</td><td>a b</td><td>c</td>   <th>0x1a</th><td><code class='op'>MUL</code> Multiply</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0b</th><td><code class='op'>LTH</code> LesserThan</td><td>a b</td><td>c</td>    <th>0x1b</th><td><code class='op'>DIV</code> Divide</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0c</th><td><code class='op'>GTS</code> GreaterSign</td><td>as bs</td><td>c</td> <th>0x1c</th><td><code class='op'>AND</code> And</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0d</th><td><code class='op'>LTS</code> LesserSign</td><td>as bs</td><td>c</td>  <th>0x1d</th><td><code class='op'>ORA</code> Or</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0e</th><td><code class='op'></code></td><td></td><td></td>                      <th>0x1e</th><td><code class='op'>EOR</code> ExclusiveOr</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0f</th><td><code class='op'></code></td><td></td><td></td>                      <th>0x1f</th><td><code class='op'>SFT</code> Shift</td><td>a b</td><td>c</td></tr>
</table>

<p><code>rs</code> for <i>return stack</i>.</p>

<img src='../media/generic/uxn.team.png' width='250' style='margin:0 auto 30px'/>

<p>Modes are indicated by appending extra characters at the end of the opcode, for example, the 16-bit mode of the <code class='op'>ADD</code> opcode is <code class='op'>ADD2</code>, modes can also be combined, for example: <code class='op'>ADD2r</code>.</p>

<p>The <b>return mode</b> makes it possible for any operator to operate on the return-stack directly, for that reason there is no return operation. For example, the JumpStash(<code class='op'>JSR</code>) operator pushes the program's address onto the return stash before jumping, to return to that address, the <code class='op'>JMPr</code> opcode is used, where instead of using the address on the working-stack, it takes its address directly from the return-stack.</p>

<pre>
#aa 
,subroutine JSR2 <span class='comment'>( push addr to return-stack )</span>
#cc

BRK

@subroutine
	#bb
	JMP2r <span class='comment'>( jump to addr in return-stack )</span>
</pre>

<p>The <b>short mode</b> allows for each operator to do 16-bits operations by pushing and popping the necessary extra items from the stack. In the case of jump opcodes(<code class='op'>JMP2</code>, <code class='op'>JSR2</code>, and <code class='op'>JNZ2</code>) the short mode operation jumps to an absolute address in memory. For the getters and setters(<code class='op'>PEK2</code>, <code class='op'>POK2</code>, <code class='op'>LDR2</code> and <code class='op'>STR2</code>) the short mode operation will point to an absolute address in memory.</p>

<pre>
#1234 #5678 ADD2 <span class='comment'>( add two shorts )</span>
	#579b EQU2 <span class='comment'>( check if result is 0x579b )</span>

#1234 #0002 MUL2 
	#2468 EQU2

#0101 EQU2 <span class='comment'>( test both comparisons )</span>
</pre>

<h2>Addressing</h2>

<p>The memory and stacks contains 8-bits values, to differentiate operations from literal numbers, the <code class='op'>LIT</code> opcode will push the following byte from memory onto the stack, the 16-bits mode <code class='op'>LIT2</code> opcode will push the following short. The <code class='op'>IND</code> opcode pushes to the stack, the value in memory found at the address defined in the following byte or short. The Uxn processor provides two ways in which literals can be created.</p>

<ul>
	<li><b>Immediate</b>, or literal, addressing allows to directly specify a byte or short constant.</li>
	<li><b>Indirect</b> addressing allows to push a byte to the stack from an address in memory. </li>
</ul>

<p>For more flexbile transfer of data between the stacks and memory, there are 4 opcodes to read/write bytes and shorts:</p>

<table border='1'>

	<tr><th></th><th>input</th><th>output</th><th>opcode</th></tr>
	<tr><th rowspan="4">read</th><th rowspan="2">byte</th><th>byte</th><td><code>PEK</code></td></tr>
	<tr><th>short</th><td><code>LDR</code></td></tr>
	<tr><th rowspan="2">short</th><th>byte</th><td><code>PEK2</code></td></tr>
	<tr><th>short</th><td><code>LDR2</code></td></tr>
	<tr><th rowspan="4">write</th><th rowspan="2">byte</th><th>byte</th><td><code>POK</code></td></tr>
	<tr><th>short</th><td><code>STR</code></td></tr>
	<tr><th rowspan="2">short</th><th>byte</th><td><code>POK2</code></td></tr>
	<tr><th>short</th><td><code>STR2</code></td></tr>

</table>

<h2>Programming</h2>

<p>Uxambly allows for basic control flow, here are some of them:</p>

<table border='1'>
	<tr><th>ForLoop</th><th>WhileLoop</th><th>Switch</th></tr>
	<tr>
		<td>
<pre>
#00 #0d
$loop
	( body ) 
	SWP #01 ADD SWP
	DUP2 LTH ;$loop JNZ
POP2
</pre>
		</td>
		<td>
<pre>
#00 #0d
$while
	( body )
	DUP2 EQU ;$end JNZ
	SWP #01 ADD SWP
;$while JMP $end
POP2
</pre>
		</td>
		<td>
<pre>
#02 
DUP #01 NEQ ;$b JNZ
	( a ) 
$b DUP #02 NEQ ;$c JNZ
	( b ) 
$c DUP #03 NEQ ;$default JNZ
	( c ) 
$default
POP
</pre>
		</td>
	</tr>

</table>

<p>Here is an example of the assembly language that prints <code>hello world</code> to stdout. Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune.</p>

<pre style='clear:both'>
%RTN { JMP2r }

( devices )

|0110 :Console { vector 2 pad 6 char 1 byte 1 short 2 string 2 }

( program )

|0200
	
	,text1 ,print-label JSR2
	,text2 ,print-label JSR2
	#ab =Console.byte
	#cdef =Console.short

BRK

@print-label ( text )
	
	$loop
		( send ) DUP2 PEK2 =Console.char
		( incr ) #0001 ADD2
		( loop ) DUP2 PEK2 #00 NEQ ;$loop JNZ
	POP2

RTN    

@text1 [ Welcome 20 to 20 UxnVM 0a00 ]
@text2 [ Hello 20 World 0a00 ] 
</pre>

<h3>Runes</h3>

<table border='1'>
	<tr><th colspan='2'>Define</th></tr>
	<tr><td><code>@label</code></td><td>Assign the current address to a label.</td></tr>
	<tr><td><code>$sublabel</code></td><td>Assign the current address to a local label.</td></tr>
	<tr><td><code>:variable { short 2 }</code></td><td>Allocate the current address to a variable.</td></tr>
	<tr><td><code>%macro { JMP2? POP2 }</code></td><td>Define a macro.</td></tr>
	<tr><th colspan='2'>Program</th></tr>
	<tr><td><code>,label</code></td><td>Push label absolute address to stack.</td></tr>
	<tr><td><code>.label</code></td><td>Push label zero-page to memory.</td></tr>
	<tr><td><code>;label</code></td><td>Push label relative address to stack.</td></tr>
	<tr><td><code>#1a</code></td><td>Push a literal byte/short.</td></tr>
	<tr><th colspan='2'>Helpers</th></tr>
	<tr><td><code>=label</code></td><td>Equivalent to <code>,label POK/STR</code>.</td></tr>
	<tr><td><code>~label</code></td><td>Equivalent to <code>,label POK/LDR</code>.</td></tr>
	<tr><th colspan='2'>Blocks</th></tr>
	<tr><td><code>( comment )</code></td><td>toggle parsing on/off.</td></tr>
	<tr><td><code>[ 0123 abcd ]</code></td><td>write data to memory.</td></tr>
	<tr><th colspan='2'>Others</th></tr>
	<tr><td><code>|0010</code></td><td>Move to position in the program.</td></tr>
</table>

<h2>Library</h2>

<pre>
%RTN   { JMP2r }
%STEP8 { #0033 SFT2 }
%MOD { DUP2 DIV MUL SUB }
%ABS { DUP #07 SHR #ff SWP MUL? }
%++ { #0001 ADD2 } %-- { #0001 SUB2 }
%2/ { #0001 SFT2 } %2* { #0010 SFT2 }
%8/ { #0003 SFT2 } %8* { #0030 SFT2 }
%8- { #0008 SUB2 } %8+ { #0008 ADD2 }
</pre>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:black; }
.clr3 { background:#ff0000; color:black; }
code.op { background: #ddd; color: black; font-size: smaller; display: inline-block; padding: 0px 2px; margin-right: 3px; }
pre span.comment { color:#666; }
</style>

<img src='../media/identity/uxn64.png' />
