
<p>Here is an example of the assembly language that prints <code>hello world</code> to stdout. Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune.</p>

<pre style='clear:both'>
( hello world )

&Console { pad 8 char 1 byte 1 short 2 }

|0100 @RESET 
	
	,text1 ,print-label JSR2
	,text2 ,print-label JSR2
	#ab =CNSL.byte
	#cdef =CNSL.short

BRK

@print-label ( text )
	
	$loop NOP
		( send ) DUP2 LDR =CNSL.char
		( incr ) #0001 ADD2
		( loop ) DUP2 LDR #00 NEQ ^$loop MUL JMPS 
	POP2

RTS    

@text1 [ Welcome 20 to 20 UxnVM 0a00 ]
@text2 [ Hello 20 World 0a00 ] 

|c000 @FRAME
|d000 @ERROR 

|FF00 ;CNSL Console

|FFF0 .RESET .FRAME .ERROR ( vectors )
|FFF8 [ 13fd 1ef3 1bf2 ] ( palette )
</pre>

<h2>Runes</h2>

<table border='1'>
	<tr><th colspan='2'>Define</th></tr>
	<tr><td><code>@label</code></td><td>Assign the current address to a label.</td></tr>
	<tr><td><code>$label</code></td><td>Assign the current address to a local label.</td></tr>
	<tr><td><code>;variable 2</code></td><td>Assign an address to a label automatically.</td></tr>
	<tr><td><code>:const 1a2b</code></td><td>Assign an address to a label manually.</td></tr>
	<tr><td><code>&amp;macro { x 2 y 2 }</code></td><td>Define a macro.</td></tr>
	<tr><th colspan='2'>Program</th></tr>
	<tr><td><code>ADDS2</code></td><td>Push an opcode.</td></tr>
	<tr><td><code>.address</code></td><td>Push label address to memory.</td></tr>
	<tr><td><code>,literal</code></td><td>Push label literal address to stack.</td></tr>
	<tr><td><code>#1a</code></td><td>Push a literal byte/short.</td></tr>
	<tr><td><code>+1a</code></td><td>Push a literal signed byte/short.</td></tr>
	<tr><td><code>-1a</code></td><td>Push a literal signed byte/short(negative).</td></tr>
	<tr><td><code>|0010</code></td><td>Move to position in the program.</td></tr>
	<tr><th colspan='2'>Helpers</th></tr>
	<tr><td><code>=label</code></td><td>Equivalent to <code>,label STR</code>.</td></tr>
	<tr><td><code>~label</code></td><td>Equivalent to <code>,label LDR2</code>.</td></tr>
	<tr><th colspan='2'>Blocks</th></tr>
	<tr><td><code>( comment )</code></td><td>toggle parsing on/off.</td></tr>
	<tr><td><code>[ 0123 abcd ]</code></td><td>write data to memory.</td></tr>
</table>

<h2>Operator modes</h2>

<ul>
	<li><code>#1234 #0001 ADD2</code>, 16-bits operators have the short flag `2`.</li>
	<li><code>#12 #11 GTH JMP?</code>, conditional operators have the cond flag `?`.</li>
	<li><code>+21 -03 MULS</code>, signed operators have the cond flag `S`.</li>
	<li><code>ADDS2?</code>, modes can be combined.</li>
</ul>

<h3>Literal mode</h3>
<p>Each operation is 1 byte(8-bits). To differentiate operations from numbers, the <code>LIT</code> opcode (0x02) toggles the literal mode for a length of 1 evaluation, the 16-bits mode <code>LIT2</code> opcode (0x22) toggles the literal mode for a length of 2 evaluations.</p>

<table border='1'>
	<tr><th><code>assembly</code></th><td><code>bytecode</code></td></tr>
	<tr><th><code>,12</code></th><td><code>0x02 0x12</code></td></tr>
	<tr><th><code>.23</code></th><td><code>0x23</code></td></tr>
	<tr><th><code>,abcd</code></th><td><code>0x22 0xab 0xcd</code></td></tr>
	<tr><th><code>.abcd</code></th><td><code>0xab 0xcd</code></td></tr>
</table>

<h3>Short mode</h3>
<p>Operations can be used on 16-bits at a time(2 bytes), by using the <code>SHORT2</code> mode. </p>

<table border='1'>
	<tr><th>Stack</th><th>Operation</th></tr>
	<tr><td><code>0x12 0x34 0x56 0x78</code></td><td>SWP2</td></tr>
	<tr><td><code>0x56 0x78 0x12 0x34</code></td><td>ADD2</td></tr>
	<tr><td><code>0x68 0xac</code></td><td></td></tr>
</table>

<h3>Conditional mode</h3>
<p>Every operation has the potential to conditionally operate by using the <code>COND?</code> mode, in the following branching example, the value <code>0xff</code> will be added to the stack if the first value is greater than the second, otherwise <code>0xee</code> will be added.</p>
<p><code>ROT</code> is used to bring the result of <code>GTH</code> to the top of the stack, <code>POP2</code> is used after the conditional <code>JMP</code> to remove the address of the label <code>@there</code> that is left on the stack.</p>

<pre>
#06 #05 GTH ,there ROT JMP? POP2

@here ( when lesser or equal )
	#ee
	BRK

@there ( when greater )
	#ff
	BRK
</pre>

<h3>Signed Mode</h3>

<p>The short mode is commonly used to do relative jumps(<code>JMPS</code>), and signed comparisons.</p>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:white; }
.clr3 { background:#ff0000; color:black; }
</style>

<img src='../media/identity/uxn64.png' />
