<h3>Opcodes</h3>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 are used to select the addressing mode of the values in the stack.</p>

<table border='1'>
	<tr><td colspan='3'>mode</td><td colspan='5'>opcode</td></tr>
	<tr><td>cond</td><td>return</td><td>short</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<p>Opcodes pointing to an address in memory can pull 16-bits(2 bytes) from the stack at a time to form an address like <code>[a b]</code>, where the a and b bytes are combined. For example, <code>[0xAB 0xCD]</code> points to the memory address <code>0xABCD</code>. When used a single byte, these operators point to a relative address.</p>

<table border='1' width='700'>
	<tr><td></td><th colspan='3'>Stack</th><td></td>                                           <th colspan='3'>Memory</th></tr>
	<tr><th>0x00</th><td><code class='op'>BRK</code> Break</td><td></td><td></td>              <th>0x10</th><td><code class='op'>LDR</code> Load</td><td>[a b]</td><td>c</td></tr>
	<tr><th>0x01</th><td><code class='op'>NOP</code> Nothing</td><td></td><td></td>            <th>0x11</th><td><code class='op'>STR</code> Store</td><td>a [b c]</td><td></td></tr>
	<tr><th>0x02</th><td><code class='op'>LIT</code> Literal</td><td></td><td>lc</td>          <th>0x12</th><td><code class='op'>---</code> </td><td></td><td></td></tr>
	<tr><th>0x03</th><td><code class='op'>POP</code> Pop</td><td>a</td><td></td>               <th>0x13</th><td><code class='op'>---</code> </td><td></td><td></td></tr>
	<tr><th>0x04</th><td><code class='op'>DUP</code> Duplicate</td><td>a</td><td>a a</td>      <th>0x14</th><td><code class='op'>---</code> </td><td></td><td></td></tr>
	<tr><th>0x05</th><td><code class='op'>SWP</code> Swap</td><td>a b</td><td>b a</td>         <th>0x15</th><td><code class='op'>---</code></td><td></td><td></td></tr>
	<tr><th>0x06</th><td><code class='op'>OVR</code> Over</td><td>a b</td><td>a b a</td>       <th>0x16</th><td><code class='op'>CLN</code> Clone</td><td>rs</td><td>rs a</td></tr>
	<tr><th>0x07</th><td><code class='op'>ROT</code> Rotate</td><td>a b c</td><td>b c a</td>   <th>0x17</th><td><code class='op'>STH</code> Stash</td><td>a</td><td>rs</td></tr>
	<tr><td></td><th colspan='3'>Logic</th><td></td>                                           <th colspan='3'>Arithmetic</th></tr>
	<tr><th>0x08</th><td><code class='op'>EQU</code> Equal</td><td>a b</td><td>c</td>          <th>0x18</th><td><code class='op'>ADD</code> Add</td><td>a b</td><td>c</td></tr>
	<tr><th>0x09</th><td><code class='op'>NEQ</code> NotEqual</td><td>a b</td><td>c</td>       <th>0x19</th><td><code class='op'>SUB</code> Subtract</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0a</th><td><code class='op'>GTH</code> GreaterThan</td><td>a b</td><td>c</td>     <th>0x1a</th><td><code class='op'>MUL</code> Multiply</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0b</th><td><code class='op'>LTH</code> LesserThan</td><td>a b</td><td>c</td>    <th>0x1b</th><td><code class='op'>DIV</code> Divide</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0c</th><td><code class='op'>GTS</code> GreaterSign</td><td>as bs</td><td>c</td>          <th>0x1c</th><td><code class='op'>AND</code> And</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0d</th><td><code class='op'>LTS</code> LesserSign</td><td>as bs</td><td>c</td>   <th>0x1d</th><td><code class='op'>ORA</code> Or</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0e</th><td><code class='op'>JMP</code> Jump</td><td>[a b]</td><td></td> <th>0x1e</th><td><code class='op'>EOR</code> ExclusiveOr</td><td>a b</td><td>c</td></tr>
	<tr><th>0x0f</th><td><code class='op'>JSR</code> JumpStash</td><td>[a b]</td><td>rs</td>  <th>0x1f</th><td><code class='op'>SFT</code> Shift</td><td>a b</td><td>c</td></tr>
</table>

<p><code>lc</code> stands for <i>literal counter</i>, <code>rs</code> for <i>return stack</i>.</p>

<h3>Literals</h3>

<p>Each operation is 1 byte(8-bits). To differentiate operations from numbers, the <code class='op'>LIT</code> opcode (0x02) toggles the literal mode for a length of 1 evaluation, the 16-bits mode <code class='op'>LIT2</code> opcode (0x22) toggles the literal mode for a length of 2 evaluations.</p>

<table border='1'>
	<tr><th><code>assembly</code></th><td><code>bytecode</code></td></tr>
	<tr><th><code>,12</code></th><td><code>0x02 0x12</code></td></tr>
	<tr><th><code>.23</code></th><td><code>0x23</code></td></tr>
	<tr><th><code>,abcd</code></th><td><code>0x22 0xab 0xcd</code></td></tr>
	<tr><th><code>.abcd</code></th><td><code>0xab 0xcd</code></td></tr>
</table>

<p>Here is an example of the assembly language that prints <code>hello world</code> to stdout. Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune.</p>

<pre style='clear:both'>
( hello world )

%RTN { JMP2r }

@RESET 
	
	,text1 ,print-label JSR2
	,text2 ,print-label JSR2
	#ab =Console.byte
	#cdef =Console.short

BRK

@print-label ( text )
	
	$loop NOP
		( send ) DUP2 LDR =Console.char
		( incr ) #0001 ADD2
		( loop ) DUP2 LDR #00 NEQ ^$loop MUL JMP 
	POP2

RTN    

@text1 [ Welcome 20 to 20 UxnVM 0a00 ]
@text2 [ Hello 20 World 0a00 ] 

|c000 @FRAME
|d000 @ERROR 

|FF00 ;Console { pad 8 char 1 byte 1 short 2 }

|FFF0 .RESET .FRAME .ERROR ( vectors )
|FFF8 [ 13fd 1ef3 1bf2 ] ( palette )
</pre>

<h3>Runes</h3>

<table border='1'>
	<tr><th colspan='2'>Define</th></tr>
	<tr><td><code>@label</code></td><td>Assign the current address to a label.</td></tr>
	<tr><td><code>$sublabel</code></td><td>Assign the current address to a local label.</td></tr>
	<tr><td><code>;variable { short 2 }</code></td><td>Assign an address to a label automatically.</td></tr>
	<tr><td><code>%macro { JMP2? POP2 }</code></td><td>Define a macro.</td></tr>
	<tr><th colspan='2'>Program</th></tr>
	<tr><td><code>.address</code></td><td>Push label address to memory.</td></tr>
	<tr><td><code>,literal</code></td><td>Push label literal address to stack.</td></tr>
	<tr><td><code>#1a</code></td><td>Push a literal byte/short.</td></tr>
	<tr><th colspan='2'>Helpers</th></tr>
	<tr><td><code>=label</code></td><td>Equivalent to <code>,label STR</code>.</td></tr>
	<tr><td><code>~label</code></td><td>Equivalent to <code>,label LDR2</code>.</td></tr>
	<tr><th colspan='2'>Blocks</th></tr>
	<tr><td><code>( comment )</code></td><td>toggle parsing on/off.</td></tr>
	<tr><td><code>[ 0123 abcd ]</code></td><td>write data to memory.</td></tr>
	<tr><th colspan='2'>Others</th></tr>
	<tr><td><code>|0010</code></td><td>Move to position in the program.</td></tr>
</table>

<h3>Operator modes</h3>

<p>Modes are used by appending the mode's rune to the end of the opcode, for example, the 16-bit mode of the <code class='op'>ADD</code> opcode is <code class='op'>ADD2</code>, modes can also be combined, for example: <code class='op'>ADD2r?</code>.</p>

<ul>
	<li><code class='op'>#12 #11 GTH JMP?</code>, conditional operators have the cond flag <code class='op'>?</code>.</li>
	<li><code class='op'>POPr</code>, return-stack operators have the return flag <code class='op'>r</code>.</li>
	<li><code class='op'>#1234 #0001 ADD2</code>, 16-bits operators have the short flag <code class='op'>2</code>.</li>
	<li><code class='op'>JSR2r?</code>, modes can also be combined.</li>
</ul>

<img src='../media/generic/uxn.team.png' width='250' style='margin:0 auto'/>

<h3>Conditional mode</h3>

<p>Every operation has the potential to conditionally operate by using the <b>conditional mode</b>, for that reason there is no conditional jump operation. In the following branching example, the value <code>0xff</code> will be added to the stack if the first value is greater than the second, otherwise <code>0xee</code> will be added.</p>

<p>The conditional mode will pop an extra byte from the stack, usually the result of a logic's operation, before proceeding with its normal operation.</p>

<pre>
,there #06 #05 GTH JMP2?

@here ( when lesser or equal )
	#ee
	BRK

@there ( when greater )
	#ff
	BRK
</pre>

<h3>Return Mode</h3>

<p>The <b>return mode</b> makes it possible for any operator to operate on the return-stack directly, for that reason there is no return operation. For example, the JumpStash(<code class='op'>JSR</code>) operator pushes the program's address onto the return stash before jumping, to return to that address, the <code class='op'>JMPr</code> opcode is used, where instead of using the address on the working-stack, it takes its address directly from the return-stack.</p>

<pre>
#aa 
,subroutine JSR2 ( push addr to return-stack )
#cc

BRK

@subroutine
	#bb
	JMP2r ( jump to addr in return-stack )
</pre>

<h3>Short mode</h3>

<p>Operations can be used on 16-bits at a time(2 bytes), by using the <code>SHORT2</code> mode. </p>

<table border='1'>
	<tr><th>Stack</th><th>Operation</th></tr>
	<tr><td><code>0x12 0x34 0x56 0x78</code></td><td>SWP2</td></tr>
	<tr><td><code>0x56 0x78 0x12 0x34</code></td><td>ADD2</td></tr>
	<tr><td><code>0x68 0xac</code></td><td></td></tr>
</table>

<h2>Library</h2>

<pre>
%RTN   { JMP2r }
%RTN?  { JMP2r? }
%STEP8 { #0033 SFT2 }

%++ { #0001 ADD2 } %-- { #0001 SUB2 }
%2/ { #0001 SFT2 } %2* { #0010 SFT2 }
%8/ { #0003 SFT2 } %8* { #0030 SFT2 }
%8- { #0008 SUB2 } %8+ { #0008 ADD2 }

%ABS { DUP #07 SHR #ff SWP MUL? }
%ABS2 { DUP2 #000f SFT2 #ffff SWP2 SWP POP MUL2? } 
</pre>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:white; }
.clr3 { background:#ff0000; color:black; }
code.op { background: #ddd; color: black; font-size: smaller; display: inline-block; padding: 0px 2px; margin-right: 3px; }
</style>

<img src='../media/identity/uxn64.png' />
