<h3>Opcodes</h3>

<p>There are 32 opcodes, each opcode occupies 5 bits of a byte, the remaining 3 are used to select the addressing mode of the values in the stack.</p>

<table border='1'>
	<tr><td colspan='3'>mode</td><td colspan='5'>opcode</td></tr>
	<tr><td>cond</td><td>sign</td><td>short</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</table>

<p>Opcodes pointing to an address in memory can pull 16-bits(2 bytes) from the stack at a time to form an address like <code>[a b]</code>, where the a and b bytes are combined. For example, <code>[0xAB 0xCD]</code> points to the memory address <code>0xABCD</code>. When used a single byte, these operators point to a relative address.</p>

<table border='1'>
	<tr><td></td><th colspan='3'>I/O</th><td></td>                      <th colspan='3'>Stack</th></tr>
	<tr><th>0x00</th><td><code>BRK</code></td><td></td><td></td>        <th>0x10</th><td><code>POP</code></td><td>a</td><td></td></tr>
	<tr><th>0x01</th><td><code>NOP</code></td><td></td><td></td>        <th>0x11</th><td><code>DUP</code></td><td>a</td><td>a a</td></tr>
	<tr><th>0x02</th><td><code>LIT</code></td><td></td><td>lc</td>      <th>0x12</th><td><code>SWP</code></td><td>a b</td><td>b a</td></tr>
	<tr><th>0x03</th><td><code>JMP</code></td><td>[a b]</td><td></td>   <th>0x13</th><td><code>OVR</code></td><td>a b c</td><td>a b a</td></tr>
	<tr><th>0x04</th><td><code>JSR</code></td><td>[a b]</td><td>rs</td> <th>0x14</th><td><code>ROT</code></td><td>a b c</td><td>b c a</td></tr>
	<tr><th>0x05</th><td><code>RTS</code></td><td></td><td>rs</td>      <th>0x15</th><td><code>---</code></td><td></td><td></td></tr>
	<tr><th>0x06</th><td><code>LDR</code></td><td>[a b]</td><td>c</td>  <th>0x16</th><td><code>WSR</code></td><td>a</td><td>rs</td></tr>
	<tr><th>0x07</th><td><code>STR</code></td><td>a [b c]</td><td></td> <th>0x17</th><td><code>RSW</code></td><td>rs</td><td>a</td></tr>
	<tr><td></td><th colspan='3'>Logic</th><td></td>                    <th colspan='3'>Arithmetic</th></tr>
	<tr><th>0x08</th><td><code>---</code></td><td></td><td></td>        <th>0x18</th><td><code>ADD</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x09</th><td><code>---</code></td><td></td><td></td>        <th>0x19</th><td><code>SUB</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0a</th><td><code>---</code></td><td></td><td></td>        <th>0x1a</th><td><code>MUL</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0b</th><td><code>---</code></td><td></td><td></td>        <th>0x1b</th><td><code>DIV</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0c</th><td><code>AND</code></td><td>a b</td><td>c</td>    <th>0x1c</th><td><code>EQU</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0d</th><td><code>XOR</code></td><td>a b</td><td>c</td>    <th>0x1d</th><td><code>NEQ</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0e</th><td><code>ROL</code></td><td>a b</td><td>c</td>    <th>0x1e</th><td><code>LTH</code></td><td>a b</td><td>c</td></tr>
	<tr><th>0x0f</th><td><code>ROR</code></td><td>a b</td><td>c</td>    <th>0x1f</th><td><code>GTH</code></td><td>a b</td><td>c</td></tr>
</table>

<p><code>lc</code> stands for <i>literal counter</i>, <code>rs</code> for <i>return stack</i>, <code>mp</code> stands for <i>memory pointer</i>.</p>

<p>Here is an example of the assembly language that prints <code>hello world</code> to stdout. Uxambly has no reserved words besides the 32 opcodes, each element of the program has its own rune.</p>

<pre style='clear:both'>
( hello world )

@RESET 
	
	,text1 ,print-label JSR2
	,text2 ,print-label JSR2
	#ab =Console.byte
	#cdef =Console.short

BRK

@print-label ( text )
	
	$loop NOP
		( send ) DUP2 LDR =Console.char
		( incr ) #0001 ADD2
		( loop ) DUP2 LDR #00 NEQ ^$loop MUL JMPS 
	POP2

RTS    

@text1 [ Welcome 20 to 20 UxnVM 0a00 ]
@text2 [ Hello 20 World 0a00 ] 

|c000 @FRAME
|d000 @ERROR 

|FF00 ;Console { pad 8 char 1 byte 1 short 2 }

|FFF0 .RESET .FRAME .ERROR ( vectors )
|FFF8 [ 13fd 1ef3 1bf2 ] ( palette )
</pre>

<h3>Runes</h3>

<table border='1'>
	<tr><th colspan='2'>Define</th></tr>
	<tr><td><code>@label</code></td><td>Assign the current address to a label.</td></tr>
	<tr><td><code>$label</code></td><td>Assign the current address to a local label.</td></tr>
	<tr><td><code>;variable 2</code></td><td>Assign an address to a label automatically.</td></tr>
	<tr><td><code>:const 1a2b</code></td><td>Assign an address to a label manually.</td></tr>
	<tr><td><code>&amp;macro { x 2 y 2 }</code></td><td>Define a macro.</td></tr>
	<tr><th colspan='2'>Program</th></tr>
	<tr><td><code>ADDS2</code></td><td>Push an opcode.</td></tr>
	<tr><td><code>.address</code></td><td>Push label address to memory.</td></tr>
	<tr><td><code>,literal</code></td><td>Push label literal address to stack.</td></tr>
	<tr><td><code>#1a</code></td><td>Push a literal byte/short.</td></tr>
	<tr><td><code>+1a</code></td><td>Push a literal signed byte/short.</td></tr>
	<tr><td><code>-1a</code></td><td>Push a literal signed byte/short(negative).</td></tr>
	<tr><td><code>|0010</code></td><td>Move to position in the program.</td></tr>
	<tr><th colspan='2'>Helpers</th></tr>
	<tr><td><code>=label</code></td><td>Equivalent to <code>,label STR</code>.</td></tr>
	<tr><td><code>~label</code></td><td>Equivalent to <code>,label LDR2</code>.</td></tr>
	<tr><th colspan='2'>Blocks</th></tr>
	<tr><td><code>( comment )</code></td><td>toggle parsing on/off.</td></tr>
	<tr><td><code>[ 0123 abcd ]</code></td><td>write data to memory.</td></tr>
</table>

<h3>Operator modes</h3>

<ul>
	<li><code>#1234 #0001 ADD2</code>, 16-bits operators have the short flag `2`.</li>
	<li><code>#12 #11 GTH JMP?</code>, conditional operators have the cond flag `?`.</li>
	<li><code>+21 -03 MULS</code>, signed operators have the cond flag `S`.</li>
	<li><code>ADDS2?</code>, modes can be combined.</li>
</ul>

<img src='../media/generic/uxn.team.png' width='250' style='margin:0 auto'/>

<h3>Literal mode</h3>
<p>Each operation is 1 byte(8-bits). To differentiate operations from numbers, the <code>LIT</code> opcode (0x02) toggles the literal mode for a length of 1 evaluation, the 16-bits mode <code>LIT2</code> opcode (0x22) toggles the literal mode for a length of 2 evaluations.</p>

<table border='1'>
	<tr><th><code>assembly</code></th><td><code>bytecode</code></td></tr>
	<tr><th><code>,12</code></th><td><code>0x02 0x12</code></td></tr>
	<tr><th><code>.23</code></th><td><code>0x23</code></td></tr>
	<tr><th><code>,abcd</code></th><td><code>0x22 0xab 0xcd</code></td></tr>
	<tr><th><code>.abcd</code></th><td><code>0xab 0xcd</code></td></tr>
</table>

<h3>Short mode</h3>
<p>Operations can be used on 16-bits at a time(2 bytes), by using the <code>SHORT2</code> mode. </p>

<table border='1'>
	<tr><th>Stack</th><th>Operation</th></tr>
	<tr><td><code>0x12 0x34 0x56 0x78</code></td><td>SWP2</td></tr>
	<tr><td><code>0x56 0x78 0x12 0x34</code></td><td>ADD2</td></tr>
	<tr><td><code>0x68 0xac</code></td><td></td></tr>
</table>

<h3>Conditional mode</h3>
<p>Every operation has the potential to conditionally operate by using the <code>COND?</code> mode, in the following branching example, the value <code>0xff</code> will be added to the stack if the first value is greater than the second, otherwise <code>0xee</code> will be added.</p>
<p><code>ROT</code> is used to bring the result of <code>GTH</code> to the top of the stack, <code>POP2</code> is used after the conditional <code>JMP</code> to remove the address of the label <code>@there</code> that is left on the stack.</p>

<pre>
#06 #05 GTH ,there ROT JMP? POP2

@here ( when lesser or equal )
	#ee
	BRK

@there ( when greater )
	#ff
	BRK
</pre>

<h3>Signed Mode</h3>

<p>The short mode is commonly used to do relative jumps(<code>JMPS</code>), and signed comparisons.</p>

<h3>Notes</h3>

<p>While the aim is to distribute assembled binaries, to respect the {about philosophy} of the tool's ecosystem, the assembly, assembler and emulator sources are packaged alongside the roms. Similarly to the emulator, the assembler is extremely simple in its implementation as to not discourage re-implementations. The assembler is 400 lines of C89 with no dependencies.</p>

<style>
.clr0 { background:white; color:black; }
.clr1 { background:black; color:white; }
.clr2 { background:#72dec2; color:white; }
.clr3 { background:#ff0000; color:black; }
</style>

<img src='../media/identity/uxn64.png' />
