<h2>Memory</h2>

<table border='1'>
	<tr><th>Core</th><td>Status</td><td>Register</td><td>1 byte</td></tr>
	<tr><th rowspan='4'>Stacks</th><td rowspan='2'>Working Stack</td><td>Pointer</td><td>1 byte</td></tr>
	<tr><td>Data</td><td>256 bytes</td></tr>
	<tr><td rowspan='2'>Return Stack</td><td>Pointer</td><td>1 byte</td></tr>
	<tr><td>Data</td><td>256 bytes</td></tr>
	<tr><th rowspan='2'>Memory</th><td rowspan='2'>RAM</td><td>Pointer</td><td>1 short</td></tr>
	<tr><td>Data</td><td>64kb</td></tr>
</table>

<h3>Status Register</h3>

<p>Uxn's state is kept in a byte which currently carries the <b>halt</b> and <b>literal</b> flags which are used to break from the current <a href='#vectors'>vector</a>, and toggle between interpret and literal mode.</p>

<pre>
T C S H
| | | +---- Halt   0x01
| | +------ Unused 0x02
| +-------- Lit1   0x04
+---------- Lit2   0x08
</pre>

<h3>Return Stack</h3>

<p>The CPU can tunnel through 128 subroutines and find its way back with the return stack, the JSR opcode jumps while pushing a return address to the return-stack, the opcode to return from a subroutine is <code>JMPr</code>. An item on the work stack can be sent to the return stack with <code>STH</code>(stash) and returned with <code>STHr</code>. To learn more, see the <a href='uxambly.html'>Uxambly</a> documentation.</p>